/**                                                               *                                                               ** Initial haXe port by Brett Johnson, http://now.periscopic.com   ** Project site: code.google.com/p/gtweenhx/                       ** . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . *** ColorAdjustPlugin by Grant Skinner. Nov 3, 2009* Visit www.gskinner.com/blog for documentation, updates and more free code.*** Copyright (c) 2009 Grant Skinner* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package com.gskinner.motion.plugins;		import com.gskinner.motion.plugins.IGTweenPlugin;	import com.gskinner.motion.GTween;	import com.gskinner.geom.ColorMatrix;	#if !(js||cpp)	import flash.filters.ColorMatrixFilter;	#end		/**	* Plugin for GTween. Applies a color matrix filter to the target based on the "brightness", "contrast", "hue", and/or "hue" tween values.	* <br/><br/>	* If a color matrix filter does not already exist on the tween target, the plugin will create one.	* Note that this may conflict with other plugins that use filters. If you experience problems,	* try applying a color matrix filter to the target in advance to avoid this behaviour.	* <br/><br/>	* Supports the following <code>pluginData</code> properties:<UL>	* <LI> ColorAdjustEnabled: overrides the enabled property for the plugin on a per tween basis.	* <LI> ColorAdjustData: Used internally.	* </UL>	**/	class ColorAdjustPlugin implements IGTweenPlugin {			// Static interface:		/** Specifies whether this plugin is enabled for all tweens by default. **/		public static var enabled:Bool;//=true;				/** @private **/		private static var instance:ColorAdjustPlugin;		/** @private **/		private static var tweenProperties:Array<String>;				static function __init__() {			enabled=true;			tweenProperties = ["brightness","contrast","hue","saturation"];		}				/**		* Installs this plugin for use with all GTween instances.		**/		public static function install():Void {			if (instance != null) { return; }			#if js				throw("ColorMatrixFilter not implemented in Jeash");			#elseif cpp				throw("ColorMatrixFilter not implemented in nme");			#else			instance = new ColorAdjustPlugin();			GTween.installPlugin(instance,tweenProperties);			#end		}				//Empty constructor		function new(){}			// Public methods:		/** @private **/		public function init(tween:GTween, name:String, value:Float):Float {			#if !(js||cpp)			if (!((tween.pluginData.ColorAdjustEnabled == null && enabled) || tween.pluginData.ColorAdjustEnabled)) { return value; }						if (tween.pluginData.ColorAdjustData == null) {				// try to find an existing color matrix filter on the target:				var f:Array<Dynamic> = tween.target.filters;								//for (var i:uint=0; i<f.length; i++) {				for(i in 0...f.length){					if(Std.is(f[i], ColorMatrixFilter)) {//if (f[i] is ColorMatrixFilter) {											var cmF:ColorMatrixFilter = cast(f[i],ColorMatrixFilter);						var o:Dynamic = {index:i,ratio:Math.NaN};												// save off the initial matrix:						o.initMatrix = cmF.matrix;												// save off the target matrix:						o.matrix = getMatrix(tween).myMatrix;												// store in pluginData for this tween for retrieval later:						tween.pluginData.ColorAdjustData = o;					}				}			}			#end			// make up an initial value that will let us get a 0-1 ratio back later:			return tween.getValue(name)-1;		}				/** @private **/		public function tween(tween:GTween, name:String, value:Float, initValue:Float, rangeValue:Float, ratio:Float, end:Bool):Float {			#if !(js||cpp)			// don't run if we're not enabled:			if (!((tween.pluginData.ColorAdjustEnabled == null && enabled) || tween.pluginData.ColorAdjustEnabled)) { return value; }						// grab the tween specific data from pluginData:			var data:Dynamic = tween.pluginData.ColorAdjustData;			if (data == null) { data = initTarget(tween); }						// only run once per tween tick, regardless of how many properties we're dealing with			// ex. don't run twice if both contrast and hue are specified, because we deal with them at the same time:			if (ratio == data.ratio) { return value; }			data.ratio = ratio;						// use the "magic" ratio we set up in init:			ratio = value-initValue;						// grab the filter:			var f:Array<Dynamic> = tween.target.filters;			var cmF:ColorMatrixFilter = cast(f[data.index], ColorMatrixFilter);			if (cmF == null) { return value; }						// grab our init and target color matrixes:			var initMatrix:Array<Dynamic> = data.initMatrix;			var targMatrix:Array<Dynamic> = data.matrix;						// check if we're running backwards:			if (rangeValue < 0) {				// values were swapped.				initMatrix = targMatrix;				targMatrix = data.initMatrix;				ratio *= -1;			}						// grab the current color matrix, and tween it's values:			#if flash8			var matrix:Array<Float> = cmF.matrix;			#else 			var matrix:Array<Dynamic> = cmF.matrix;			#end			//var l:uint = matrix.length;			for(i in 0...matrix.length){//for (var i:uint=0; i<l; i++) {				matrix[i] = initMatrix[i]+(targMatrix[i]-initMatrix[i])*ratio;			}						// set the matrix back to the filter, and set the filters on the target:			cmF.matrix = matrix;			tween.target.filters = f;						// clean up if it's the end of the tween:			//cleaning this up causes initTarget to be called again when 2 or more color properties are being tweened			/*if (end) {				Reflect.deleteField(tween.pluginData,"ColorAdjustData");//delete(tween.pluginData.ColorAdjustData);			}*/			#end			// tell GTween not to use the default assignment behaviour:			return Math.NaN;		}			// Private methods:		/** @private **/		private function getMatrix(tween:GTween):ColorMatrix {			var brightness:Float = fixValue(tween.getValue("brightness"));			var contrast:Float = fixValue(tween.getValue("contrast"));			var saturation:Float = fixValue(tween.getValue("saturation"));			var hue:Float = fixValue(tween.getValue("hue"));			var mtx:ColorMatrix = new ColorMatrix();						mtx.adjustColor(brightness,contrast,saturation,hue);						return mtx;		}				/** @private **/		private function initTarget(tween:GTween):Dynamic {			#if (js||cpp)			return null;			#else			var f:Array<Dynamic> = tween.target.filters;			var mtx:ColorMatrix = new ColorMatrix();			f.push(new ColorMatrixFilter(mtx.myMatrix));			tween.target.filters = f;			var o:Dynamic = {index:f.length-1, ratio:Math.NaN};			o.initMatrix = mtx.myMatrix;			o.matrix = getMatrix(tween).myMatrix;			return tween.pluginData.ColorAdjustData = o;			#end		}				/** @private **/		private function fixValue(value:Float):Float {			return Math.isNaN(value) ? 0 : value;		}					}